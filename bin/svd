#!/usr/bin/env python
from subprocess import call
import base64
import os
import re
import requests
import sys
import tempfile

master_json_url = sys.argv[-1]
print 'downloading json %s' % master_json_url
base_url = master_json_url[:master_json_url.rfind('/', 0, -26) + 1]


resp = requests.get(master_json_url)
content = resp.json()


def get_best_descriptor(descriptors, sorting_field):
  fields = [(i, d[sorting_field]) for (i, d) in enumerate(descriptors)]
  idx, _ = max(fields, key=lambda (_, h): h)
  return descriptors[idx]

def process_descriptor(descriptor, base_url):
  descriptor_base_url = base_url + descriptor['base_url']
  descriptor_base_url = re.sub(r"/[^/]+/\.\./", "/", descriptor_base_url)
  print 'base_url:', descriptor_base_url

  output_file = tempfile.NamedTemporaryFile(mode='wb', delete=False)
  print 'saving to {}'.format(output_file.name)

  download_segments(descriptor, descriptor_base_url, output_file)

  output_file.flush()
  output_file.close()
  return output_file


def download_segments(descriptor, base_url, output_file):
  init_segment = base64.b64decode(descriptor['init_segment'])
  output_file.write(init_segment)

  segments = descriptor['segments']
    
  for idx, segment in enumerate(descriptor['segments']):
    segment_url = base_url + segment['url']
    if idx % 10 == 0:
      print "{} / {}".format(idx, len(segments))
    resp = requests.get(segment_url, stream=True)
    
    if resp.status_code != 200:
      print 'not 200!'
      print resp
      print segment_url
      break
    for chunk in resp:
      output_file.write(chunk)

video_file = process_descriptor(get_best_descriptor(content['video'], 'height'), base_url)
audio_file = process_descriptor(get_best_descriptor(content['audio'], 'bitrate'), base_url)

print 'Merging video an audio'
call([
"ffmpeg",
"-i", video_file.name,
"-i", audio_file.name,
"-c:v", "copy",
"-c:a", "aac",
"-strict", "experimental",
"final_video.mp4"
])

print 'Removing tmp files'
os.unlink(video_file.name)
os.unlink(audio_file.name)